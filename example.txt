import processing.video.*;

Capture video;
int[] backgroundPixels;
boolean backgroundCaptured = false;
boolean countdownActive = true;
boolean setupComplete = false;
int framesToAverage = 30;
int frameCountForBg = 0;
float[] rSum, gSum, bSum;

// Display handling
boolean isHighDPI = false;
float pixelDensity = 1.0;
int actualWidth, actualHeight;

// Motion detection parameters
int threshold = 60;
int motionMode = 0; // 0=RGB, 1=Luminance, 2=Morphological, 3=Edge-based
float adaptiveThreshold = 60.0;
int noiseFilter = 5;
boolean updateBackground = false;
float backgroundLearningRate = 0.01;

// Blob detection parameters
int minBlobSize = 100; // Minimum pixels for a blob
int morphologySize = 3; // Size of erosion/dilation
boolean[] motionMask; // Binary mask for motion areas
int blobCount = 0;

// Countdown variables
int countdownStart;
int countdownDuration = 5000;

void setup() {
  fullScreen(P3D);
  
  String[] cameras = Capture.list();
  if (cameras.length > 0) {
    println("Available cameras:");
    for (int i = 0; i < cameras.length; i++) {
      println("[" + i + "] " + cameras[i]);
    }
    video = new Capture(this);
  } else {
    println("No cameras found!");
    exit();
  }
  
  video.start();
  println("Waiting for camera...");
}

void draw() {
  if (video.available()) {
    video.read();
    
    if (!setupComplete && video.width > 0 && video.height > 0) {
      // DETECT DISPLAY TYPE
      loadPixels();
      int logicalPixels = width * height;
      int physicalPixels = pixels.length;
      
      println("=== DISPLAY DETECTION ===");
      println("Logical size: " + width + "x" + height + " = " + logicalPixels + " pixels");
      println("Physical pixels: " + physicalPixels);
      
      if (physicalPixels > logicalPixels * 1.5) {
        // High DPI detected
        isHighDPI = true;
        pixelDensity = sqrt((float)physicalPixels / logicalPixels);
        actualWidth = int(width * pixelDensity);
        actualHeight = int(height * pixelDensity);
        
        println("HIGH DPI DETECTED!");
        println("Pixel density: " + nf(pixelDensity, 1, 2) + "x");
        println("Actual resolution: " + actualWidth + "x" + actualHeight);
        
        // Initialize for high DPI
        rSum = new float[physicalPixels];
        gSum = new float[physicalPixels];
        bSum = new float[physicalPixels];
        backgroundPixels = new int[physicalPixels];
        motionMask = new boolean[physicalPixels];
        
      } else {
        // Standard DPI
        isHighDPI = false;
        actualWidth = width;
        actualHeight = height;
        
        println("STANDARD DPI DETECTED");
        println("Using logical resolution: " + width + "x" + height);
        
        // Initialize for standard DPI
        rSum = new float[logicalPixels];
        gSum = new float[logicalPixels];
        bSum = new float[logicalPixels];
        backgroundPixels = new int[logicalPixels];
        motionMask = new boolean[logicalPixels];
      }
      
      println("Arrays sized to: " + backgroundPixels.length + " pixels");
      println("=========================");
      
      setupComplete = true;
      countdownStart = millis();
    }
    
    if (!setupComplete) {
      background(50);
      fill(255);
      textAlign(CENTER);
      text("Detecting display...", width/2, height/2);
      textAlign(LEFT);
      return;
    }
    
    if (countdownActive) {
      // COUNTDOWN
      int remaining = countdownDuration - (millis() - countdownStart);
      
      if (remaining > 0) {
        // SHOW FULLSCREEN CAMERA
        image(video, 0, 0, width, height);
        
        fill(0, 150);
        rect(0, 0, width, height);
        
        int countdownNum = int(remaining / 1000.0) + 1;
        float pulse = map(remaining % 1000, 0, 1000, 1.0, 0.7);
        
        fill(255, 50, 50);
        textAlign(CENTER, CENTER);
        textSize(min(width, height) * 0.15 * pulse);
        text(countdownNum, width/2, height/2);
        textAlign(LEFT);
      } else {
        countdownActive = false;
        println("Starting background capture...");
      }
      
    } else if (!backgroundCaptured) {
      // BACKGROUND CAPTURE - Handle both DPI types
      
      // SHOW FULLSCREEN CAMERA
      image(video, 0, 0, width, height);
      
      // CAPTURE SCREEN PIXELS
      loadPixels();
      int pixelsToProcess = min(pixels.length, rSum.length);
      
      for (int i = 0; i < pixelsToProcess; i++) {
        color c = pixels[i];
        rSum[i] += (c >> 16) & 0xFF;
        gSum[i] += (c >> 8) & 0xFF;
        bSum[i] += c & 0xFF;
      }
      
      frameCountForBg++;
      
      if (frameCountForBg >= framesToAverage) {
        // Create background from averages
        int bgPixelsToSet = min(backgroundPixels.length, rSum.length);
        
        for (int i = 0; i < bgPixelsToSet; i++) {
          int r = int(rSum[i] / framesToAverage);
          int g = int(gSum[i] / framesToAverage);
          int b = int(bSum[i] / framesToAverage);
          backgroundPixels[i] = color(r, g, b);
        }
        backgroundCaptured = true;
        
        println("Background captured! Processed " + bgPixelsToSet + " pixels");
        if (isHighDPI) {
          println("High DPI mode: Full " + actualWidth + "x" + actualHeight + " resolution");
        } else {
          println("Standard DPI mode: " + width + "x" + height + " resolution");
        }
        
        // Free memory
        rSum = null;
        gSum = null;
        bSum = null;
      }
      
      // Progress bar
      fill(0, 150);
      rect(0, height - 40, width, 40);
      fill(0, 255, 0);
      rect(0, height - 40, map(frameCountForBg, 0, framesToAverage, 0, width), 40);
      
    } else {
      // MOTION DETECTION - Works for both DPI types
      
      // 1. SHOW FULLSCREEN CAMERA
      image(video, 0, 0, width, height);
      
      // 2. LOAD SCREEN PIXELS
      loadPixels();
      
      // 3. BLOB-BASED MOTION DETECTION
      int effectPixels = min(pixels.length, backgroundPixels.length);
      
      // Step 1: Create binary motion mask
      for (int i = 0; i < effectPixels; i++) {
        color currentPixel = pixels[i];
        color bgPixel = backgroundPixels[i];
        float diff = calculateMotionDifference(currentPixel, bgPixel, min(motionMode, 1)); // Use basic detection first
        motionMask[i] = (diff > threshold);
      }
      
      // Step 2: Apply morphological operations for cleaner blobs
      if (motionMode >= 2) {
        morphologyOperations();
      }
      
      // Step 3: Find and filter blobs
      blobCount = 0;
      if (motionMode >= 2) {
        filterBlobsBySize();
      }
      
      // Step 4: Apply effect only to valid motion blobs
      for (int i = 0; i < effectPixels; i++) {
        if (motionMask[i]) {
          // MOTION BLOB DETECTED - RANDOM COLOR
          pixels[i] = color(int(random(256)), int(random(256)), int(random(256)));
        }
        
        // Optional: Update background model for adaptive tracking
        if (updateBackground && !motionMask[i]) {
          backgroundPixels[i] = lerpColor(backgroundPixels[i], pixels[i], backgroundLearningRate);
        }
      }
      
      // 4. UPDATE SCREEN
      updatePixels();
      
      // Info - adaptive to display type
      fill(0, 150);
      rect(0, 0, 700, 160);
      fill(255);
      textSize(16);
      text("FPS: " + nf(frameRate, 1, 1) + " | Threshold: " + threshold, 10, 20);
      text("Display: " + (isHighDPI ? "High DPI (" + nf(pixelDensity, 1, 1) + "x)" : "Standard DPI"), 10, 40);
      text("Motion Mode: " + getMotionModeName(motionMode) + " (M to cycle)", 10, 60);
      text("Min Blob Size: " + minBlobSize + " ([/] to adjust)", 10, 80);
      text("Background Update: " + (updateBackground ? "ON" : "OFF") + " (B to toggle)", 10, 100);
      text("Blobs detected: " + blobCount, 10, 120);
      text("Controls: Up/Down=Threshold, M=Mode, [/]=BlobSize, B=Background, R=Reset", 10, 140);
    }
  }
}

void keyPressed() {
  if (!setupComplete) return;
  
  if (key == 'r' || key == 'R') {
    countdownActive = true;
    backgroundCaptured = false;
    frameCountForBg = 0;
    countdownStart = millis();
    
    // Reinitialize arrays - adaptive to display type
    loadPixels();
    int arraySize = backgroundPixels.length; // Keep same size as before
    rSum = new float[arraySize];
    gSum = new float[arraySize];
    bSum = new float[arraySize];
    motionMask = new boolean[arraySize];
    
    println("Restarting... Arrays sized to: " + arraySize + " pixels");
  }
  
  if (key == 's' || key == 'S') {
    countdownActive = false;
    println("Skipping countdown");
  }
  
  if (keyCode == UP) {
    threshold += 10;
    if (threshold > 200) threshold = 200;
    println("Threshold: " + threshold);
  }
  
  if (keyCode == DOWN) {
    threshold -= 10;
    if (threshold < 10) threshold = 10;
    println("Threshold: " + threshold);
  }
  
  if (key == 'm' || key == 'M') {
    motionMode = (motionMode + 1) % 4;
    println("Motion Mode: " + getMotionModeName(motionMode));
  }
  
  if (key == 'b' || key == 'B') {
    updateBackground = !updateBackground;
    println("Background Update: " + (updateBackground ? "ON" : "OFF"));
  }
  
  if (key == '[') {
    minBlobSize = max(10, minBlobSize - 50);
    println("Min Blob Size: " + minBlobSize);
  }
  
  if (key == ']') {
    minBlobSize = min(1000, minBlobSize + 50);
    println("Min Blob Size: " + minBlobSize);
  }
  
  if (key == 'd' || key == 'D') {
    println("=== DISPLAY INFO ===");
    println("Display type: " + (isHighDPI ? "High DPI" : "Standard DPI"));
    if (isHighDPI) {
      println("Pixel density: " + nf(pixelDensity, 1, 2) + "x");
      println("Actual resolution: " + actualWidth + "x" + actualHeight);
    }
    println("Logical size: " + width + "x" + height);
    println("Physical pixels: " + pixels.length);
    println("Background pixels: " + backgroundPixels.length);
    println("Camera: " + video.width + "x" + video.height);
    println("FPS: " + frameRate);
    println("Threshold: " + threshold);
    println("Motion Mode: " + getMotionModeName(motionMode));
  }
}

// MOTION DETECTION ALGORITHMS
float calculateMotionDifference(color currentPixel, color bgPixel, int mode) {
  switch(mode) {
    case 0: return rgbDifference(currentPixel, bgPixel);
    case 1: return luminanceDifference(currentPixel, bgPixel);
    case 2: return adaptiveDifference(currentPixel, bgPixel);
    case 3: return noiseFilteredDifference(currentPixel, bgPixel);
    default: return rgbDifference(currentPixel, bgPixel);
  }
}

// Mode 0: Simple RGB difference (original)
float rgbDifference(color currentPixel, color bgPixel) {
  return abs(((currentPixel >> 16) & 0xFF) - ((bgPixel >> 16) & 0xFF)) +
         abs(((currentPixel >> 8) & 0xFF) - ((bgPixel >> 8) & 0xFF)) +
         abs((currentPixel & 0xFF) - (bgPixel & 0xFF));
}

// Mode 1: Luminance-based (less sensitive to color changes)
float luminanceDifference(color currentPixel, color bgPixel) {
  float currentLum = 0.299 * ((currentPixel >> 16) & 0xFF) + 
                     0.587 * ((currentPixel >> 8) & 0xFF) + 
                     0.114 * (currentPixel & 0xFF);
  float bgLum = 0.299 * ((bgPixel >> 16) & 0xFF) + 
                0.587 * ((bgPixel >> 8) & 0xFF) + 
                0.114 * (bgPixel & 0xFF);
  return abs(currentLum - bgLum) * 3; // Scale to match RGB range
}

// Mode 2: Adaptive threshold (adjusts based on local variations)
float adaptiveDifference(color currentPixel, color bgPixel) {
  float rgbDiff = rgbDifference(currentPixel, bgPixel);
  // Simple adaptive scaling - you could make this more sophisticated
  adaptiveThreshold = lerp(adaptiveThreshold, rgbDiff, 0.01);
  return rgbDiff / (adaptiveThreshold * 0.01 + 1); // Normalize
}

// Mode 3: Noise-filtered (requires minimum change)
float noiseFilteredDifference(color currentPixel, color bgPixel) {
  float diff = rgbDifference(currentPixel, bgPixel);
  return (diff > noiseFilter) ? diff : 0;
}

String getMotionModeName(int mode) {
  switch(mode) {
    case 0: return "RGB Difference";
    case 1: return "Luminance Only"; 
    case 2: return "Morphological Blobs";
    case 3: return "Edge-Based Blobs";
    default: return "Unknown";
  }
}

// BLOB DETECTION FUNCTIONS
void morphologyOperations() {
  // Get screen dimensions
  int w = isHighDPI ? actualWidth : width;
  int h = isHighDPI ? actualHeight : height;
  
  // Erosion (remove noise)
  boolean[] temp = new boolean[motionMask.length];
  for (int y = morphologySize; y < h - morphologySize; y++) {
    for (int x = morphologySize; x < w - morphologySize; x++) {
      int idx = y * w + x;
      if (idx < motionMask.length) {
        boolean hasMotion = true;
        // Check neighborhood
        for (int dy = -morphologySize; dy <= morphologySize && hasMotion; dy++) {
          for (int dx = -morphologySize; dx <= morphologySize && hasMotion; dx++) {
            int neighborIdx = (y + dy) * w + (x + dx);
            if (neighborIdx >= 0 && neighborIdx < motionMask.length) {
              if (!motionMask[neighborIdx]) {
                hasMotion = false;
              }
            }
          }
        }
        temp[idx] = hasMotion;
      }
    }
  }
  
  // Dilation (restore size)
  for (int y = morphologySize; y < h - morphologySize; y++) {
    for (int x = morphologySize; x < w - morphologySize; x++) {
      int idx = y * w + x;
      if (idx < motionMask.length) {
        boolean hasMotion = false;
        // Check neighborhood
        for (int dy = -morphologySize; dy <= morphologySize && !hasMotion; dy++) {
          for (int dx = -morphologySize; dx <= morphologySize && !hasMotion; dx++) {
            int neighborIdx = (y + dy) * w + (x + dx);
            if (neighborIdx >= 0 && neighborIdx < temp.length) {
              if (temp[neighborIdx]) {
                hasMotion = true;
              }
            }
          }
        }
        motionMask[idx] = hasMotion;
      }
    }
  }
}

void filterBlobsBySize() {
  // Get screen dimensions
  int w = isHighDPI ? actualWidth : width;
  int h = isHighDPI ? actualHeight : height;
  
  boolean[] visited = new boolean[motionMask.length];
  boolean[] validBlobs = new boolean[motionMask.length];
  blobCount = 0;
  
  for (int i = 0; i < motionMask.length; i++) {
    if (motionMask[i] && !visited[i]) {
      // Found new blob, flood fill to measure size
      int blobSize = floodFill(i, visited, w, h);
      
      if (blobSize >= minBlobSize) {
        // Mark this blob as valid
        markBlob(i, validBlobs, w, h);
        blobCount++;
      }
    }
  }
  
  // Replace motion mask with filtered blobs
  motionMask = validBlobs;
}

int floodFill(int startIdx, boolean[] visited, int w, int h) {
  // Simple flood fill to count blob size
  ArrayList<Integer> stack = new ArrayList<Integer>();
  stack.add(startIdx);
  int size = 0;
  
  while (stack.size() > 0) {
    int idx = stack.remove(stack.size() - 1);
    if (idx < 0 || idx >= visited.length || visited[idx] || !motionMask[idx]) {
      continue;
    }
    
    visited[idx] = true;
    size++;
    
    // Add neighbors
    int x = idx % w;
    int y = idx / w;
    
    if (x > 0) stack.add(idx - 1);
    if (x < w - 1) stack.add(idx + 1);
    if (y > 0) stack.add(idx - w);
    if (y < h - 1) stack.add(idx + w);
  }
  
  return size;
}

void markBlob(int startIdx, boolean[] validBlobs, int w, int h) {
  // Mark entire blob as valid
  ArrayList<Integer> stack = new ArrayList<Integer>();
  boolean[] blobVisited = new boolean[motionMask.length];
  stack.add(startIdx);
  
  while (stack.size() > 0) {
    int idx = stack.remove(stack.size() - 1);
    if (idx < 0 || idx >= blobVisited.length || blobVisited[idx] || !motionMask[idx]) {
      continue;
    }
    
    blobVisited[idx] = true;
    validBlobs[idx] = true;
    
    // Add neighbors
    int x = idx % w;
    int y = idx / w;
    
    if (x > 0) stack.add(idx - 1);
    if (x < w - 1) stack.add(idx + 1);
    if (y > 0) stack.add(idx - w);
    if (y < h - 1) stack.add(idx + w);
  }
}
